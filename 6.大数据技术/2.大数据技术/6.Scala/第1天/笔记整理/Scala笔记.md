## Scala笔记

-------

### 概述

> **Spark**是现今大数据场景中常用的计算框架，开发是**Scala**

> 特点
>
> > 多范式语言
> >
> > > 完全面向对象和函数式编程
> >
> > 简洁、高效、灵活 - 遵循"能省则省"的思想
> >
> > 运行环境是基于JVM
> >
> > 专门为程序员设计的语言，不适合于小白



#### 主函数的概述

> 所有的方法和类只要不指定，默认就是**public**的，所以导致再Scala中**没有public关键字**
>
> 使用**def**来定义函数
>
> Scala中不只是**static**关键字，在object中定义函数默认都是**static**的，在class中定义的函数默认都是**非静态的**
>
> Scala中不支持void关键字，如果一个函数**返回值为空**，则返回值定义为**Unit**类型



#### 基本语法

##### 定义变量

> 在Scala中，使用的是var关键字来定义变量
>
> > 显示声明
> >
> > > `var 变量名：类型 = 值`
> >
> > 隐式声明
> >
> > > `var 变量名 = 值`
> >
> > Scala在底层会**自动推导**变量的类型
>
> Scala是一门**强类型**语言
>
> > 变量在定义好之后类型不能发生改变
>
> Scala中变量在定义的时候必须**初始化**

##### 数据类型

##### 类型

> 顶级父类	-Any
>
> > 所有的都是这个类的子类
>
> 任意值	-AnyVal
>
> > 类似于Java中的基本类型，包含
>
> 任意引用	-AnyRef
>
> > 例如包含Null
>
> Nothing
>
> > 用于存储一个非正常值
> >
> > 是所有类型的子类

> 任意值类型和任意引用类型之间不能转换

##### 类型的转换

> 隐式转换	`-implicit`
>
> 方式一：小类型转化为大类型
>
> 方式二：自定义隐式转换规则
>
> > 如果要自定义隐式转换的规则，需要将规则以函数的形式来体现
> >
> > implicit是隐藏的意思
> >
> > 定义一个隐藏函数，这个函数在使用的时候不需要调用，会自动转化为指定规则
>
> 显示转化	
>
> > 向上造型的转换
> >
> > > `var o: Object = "abc"`
> > >
> > > `var str: String = o.asInstanceOf[String]`

```java
package cn.tedu.scala

object TypeChangeDemo {

  def main(args: Array[String]): Unit = {

    // 隐式转换
    // 方式一：小类型转化为大类型
    var i = 5
    var d: Double = i
    // 方式二：自定义隐式转换规则
    // 如果要自定义隐式转换的规则，需要将规则以函数的形式来体现
    // implicit是隐藏的意思
    // 定义一个隐藏函数，这个函数在使用的时候不需要调用，会自动转化为指定规则
    implicit def test(dou: Double): Int = {
      return dou.toInt
    }
    // Scala在运行的时候发现不符合自动转化的规则，就会去当前作用域内去检查是否有自定义的转化规则
    // 如果有自定义的转化规则，会自动调用这个转化规则
    // 下面的语句等价于：var id:Int = test(2.56)
    var id: Int = 2.56

    // 显式转换
    // 方式一：调用toXXX来转换
    var i2: Int = 5.23.toInt
    var i3: Int = "132".toInt
    println(i3)
    // 方式二：向上造型的转换
    var o: Object = "abc"
    var str: String = o.asInstanceOf[String]
    println(str)
  }
}
```



#### 标识符和关键字

##### 标识符的命名规则

> 可以使用字母、数字、_以及$
>
> _不能结尾
>
> 数字不能开头
>
> 允许使用其他符号作为标识符
>
> 如果使用了符号作为标识符，那么整个标识符只能使用符号
>
> 用于``作为标识符，``可以使用任何字符
>
> 注意：标识符不建议全部使用_

##### 关键字

> package, import, class, **object**, **trait**, extends, **with**, **type**, for，                                               
>
> private, protected, abstract, **sealed**, final，**implicit**,**lazy**,**override**，
>
> try, catch, finally, throw ，if, else, **match**, **case**, do, while, return, **yield**，
>
> **def**, **val**, **var** ，this, super，new，true, false, null

###### object

> 所有属性，方法都是静态

###### trait

> 相当于java中的接口，允许定义实体类

###### override

> 重写父类方法

###### yield

> 将值以数组的形式输出

###### def

> 声明函数

###### val

> 定义常量

###### var

> 定义变量

###### with

> 一个类已经继承一个类，需要用with，混入特质
>
> 也可以给对象混入特质
>
> 如果混入多个特质，要求方法名不同

###### try，catch，case，finally

> 这几个关键字可以结合使用



#### 操作符

> 不支持++/--操作
>
> Scala是一门完全面向对象的语言，所以所有的运算符本质上是一个函数
>
> Scala不支持三元运算
>
> 任意运算都有返回结果



#### 流程控制

> Scala中不支持switch-case
>
> if以及循环结构都有返回值
>
> 没有break和continue关键字





### 函数式编程

> ##### 闭包，柯里化 -基于闭包做了简化，高阶函数

#### 概述

> Scala是一门支持函数式编程的语言
>
> > 即在Scala中函数是一等公民，
> >
> > 函数可以不依存于类、对象存在，
> >
> > 且函数可以作为参数或者返回值进行传递或者返回

#### 函数的定义

> 基本结构
>
> > `权限修饰符 def 函数名(参数列表):返回值类型 = {函数体}`
>
> 返回值的类型推导
>
> > `权限修饰符 def 函数名(参数列表) = {函数体}`
>
> 没有返回值
>
> > `权限修饰符 def 函数名(参数列表){函数体}`

#### 细节

> 函数**默认是public的**
>
> 如果不写return，函数的最后一行的执行结果默认作为返回结果
>
> 如果定义函数的时候，没有写返回值类型，需要Scala自动推导
>
> > 那么在函数中不能写return，默认把**最后一行执行结果的类型作为返回值类型**

