## day11

---

### 知识点1 垃圾分代回收机制

#### 1、**栈**：用于==计算==

+ 这块肯定**不会产生垃圾**，涉及不到回收问题

#### 2、**方法区**：==存储类==的信息

+ 这块也**没有垃圾**

#### 3、**堆**：无用对象(<u>需要垃圾回收</u>)

+ 需要回收垃圾：<u>**无用对象**</u>

####==`扩展知识点：`==

> **C/C++**：提前开辟内存（需要**程序员操作**完成）
>
> **Java**：**自动**开辟内存（由Java自己完成，自动分配，无需关心创建与回收），但是<u>Java程序员</u>**无法干预**开辟、维护、回收（程序员只能通知，无法参与）
>
> > java针对所有的数据类型的内存从一开始就确定了，我们只需要把重心放在代码逻辑上
> >
> > **宏观过程**：在程序启动的时候，开始监测堆内存的使用情况，如果堆内存的使用率**超过70%**就会==通知==**GC垃圾收集器（Garbage Collecter）**进行垃圾回收

+ 堆内存从垃圾回收的角度可以分为新生代（伊甸园区、幸村区（fromspace、tospace））以及老生代，新创建的对象先放在新生代的伊甸园区，开始进行一次扫描，如果检测到对象无用通知系统进行回收，如果还是使用就把对象移动到老生代。进行多次扫描，如果检测到对象无用通知系统，进行垃圾回收。如果还在使用就继续呆在老生代
+ 老生代的扫描频率幸存区的扫描频率低
+ 如果老生代的对象突然销毁就可能会导致系统崩溃

`新生代回收（minor collect）：初代回收`

`老生代回收（full collect）：完全回收`

####==相关问题==

##### 1、如果一个新创建的对象内存较大？

`答：如果新对象的内存较大，在新生代存储不了，会进行一次初代回收，再往新生代存储，如果新生代还是存储不了，会进行第二次回收，再往新生代存储，如果还是存储不了，就把新对象移动到老生代进行存储，如果在老生代还是存储不了，会进行一次完全回收，新对象要往新生代存储，如果新生代还是存储不了，会进行第三次初代回收，新对象要往新生代存储，如果新生代还是存储不了，把新对象移动到老生代存储，新生代还是存储不了，会进行第二次完全回收，新对象要往新生代进行存储，对象依然存储不了，就把对象移动到老生代，对象依然还是存储不了系统就报错---OutOfMemoryError内存溢出错误`

> ==第1次== **新生代**存储失败
>
> 第1次 **初代回收**
>
> > ==第2次== **新生代**存储失败
> >
> > 第2次 **初代回收**
> >
> > > ==第3次== **新生代**存储失败
> > >
> > > > 第1次 **老生代**存储失败
> > > >
> > > > 第1次 **完全回收**
> > > >
> > > > > ==第4次== **新生代**存储失败
> > > > >
> > > > > 第3次 **初代回收**
> > > > >
> > > > > > ==第5次== **新生代**存储失败
> > > > > >
> > > > > > > 第2次 **老生代**存储失败
> > > > > > >
> > > > > > > 第2次 **完全回收**
> > > > > > >
> > > > > > > > ==第6次== **新生代**存储失败
> > > > > > > >
> > > > > > > > > 第3次 **老生代**存储失败
> > > > > > > > >
> > > > > > > > > `报错:` ==`OutOfMemoryError内存溢出错误`==



### 知识点2 API

####1. 概念

+ API`---`Application Programming Interface: 提供了一系列的接口以及接口下的类(大量的不写明访问权限修饰符的都是`public`,写明的都是`protected`)
+ Object: 是所有类的父类, java中的顶级父类, 所有类默认继承Object类

#### 2. 六个方法

##### 1. **`clone()`**:

+ 概念: 创建并返回此对象的副本

+ 注意:

  > 1. 对象对应的类需要实现接口`Cloneable` 才能支持克隆: ==`implements Cloneable`==
  > 2. ==.clone()`==: `add throws declaration `
  > 3. `Cloneable`仅仅是提供一个**标记**

  ```java
  //1. clone()
  public class ObjectDemo1 implements Cloneable {
  
  	private int i=1;
  
  	public static void main(String[] args) throws CloneNotSupportedException  {
  		
  		//创建对象
  		ObjectDemo1 od = new ObjectDemo1();
  		//返回Object类型
  		//选declaration
  		//CloneNotSupportedException：克隆不支持异常
  		//对象对应的类需要实现:implements Cloneable接口才能支持克隆
  		//Cloneable接口仅仅是提供了一个标记，实现了这个接口就能支持克隆
  		ObjectDemo1 od1 = (ObjectDemo1)od.clone();
  		//克隆对象调用属性
  		System.out.println(od1.i);
  		//克隆对象是开辟一块新空间，这个空间复制了原空间的所有信息
  		System.out.println(od==od1);//输出为:false
  		
          //被protected修饰的信息,子类对象要在子类的本类中使用
  		ObDemo od2 = new ObDemo();
  		od2.clone();
  
  	}
  
  }
  
  class ObDemo extends ObjectDemo1 implements Cloneable{
  	
  }
  ```




