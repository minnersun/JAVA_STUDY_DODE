## 课程目录

----

### 第十一天

> jedis客户端对JedisCluster的封装 + 利用登陆实现顶替效果 + 商品的缓存功能

> jedis的客户端对JedisCluster封装（最终版）
>
> > 代码
> >
> > > 略
>
> > 由于集群两两互连，可以通过任何一个节点来获取整个集群的信息
> >
> > JedisCluster封装了连接池和底层hash槽计算分片的方法，自带高可用的客户端功能
>
> > 创建一个公用的系统 redisCluster
> >
> > > `pom.xml`
> > >
> > > > 继承parent工程
> > > >
> > > > > 让parent工程来控制版本
> > > >
> > > > 添加redis依赖
> > >
> > > 其他代码
> > >
> > > > 略
>
> > jedisCluster的逻辑
> >
> > > 初始化
> > >
> > > > 根据提供的各种参数，初始化一个JedisCluster
> > > >
> > > > 创建一个JedisCluster对象
> > >
> > > > 连接node
> > > >
> > > > 通过连接集群的节点使用`cluster-nodes`命令获取所有节点和槽的信息
> > >
> > > > 利用收集的信息封装一个mapper对象
> > > >
> > > > > key：节点名称
> > > > >
> > > > > value：连接池对象
> > > >
> > > > > 例如
> > > > >
> > > > > > 8000 -------- JedisPool8000
> > > > > >
> > > > > > 8001--------- JedisPool8001
> > > > > >
> > > > > > 。。。
> > >
> > > > 获取槽与节点的关系
> > > >
> > > > > 举例
> > > > >
> > > > > > 0 --– 5460
> > > > > >
> > > > > > 5461 --– 10922
> > > > > >
> > > > > > 10923 --- 16383
> > > > >
> > > > > > 0 ------ JedisPool8000
> > > > > >
> > > > > > 1 ------ JedisPool8000
> > > > > >
> > > > > > ......
> > > > > >
> > > > > > 5460 -----JedisPool8001
> > > > > >
> > > > > > 5461----- JedisPool8001
> > > > > >
> > > > > > .......
> > >
> > > 初始化结束
>
> 
>
> 用户系统功能（最终版本）
>
> > 代码
> >
> > > 略
>
> > 利用登陆实现顶替效果
> >
> > > 每个账户只能有一个登录状态
> > >
> > > > 作业：一个用户最多登陆三次（可以使用list，未完成）
> >
> > > 通过多个浏览器，同一个用户可以登录使用使用系统
> > >
> > > 使用redis实现顶替
>
> 
>
>
> 商品的缓存功能
>
> > 查询商品
> >
> > 更新商品
>
> > 查询商品
> >
> > > 判断redis缓存中是否存在更新锁（` "product_update_"+productId +".lock"`）
> > >
> > > > 如果reids中 更新锁存在，直接从数据库获取数据
> > >
> > > > 如果redis中 更新锁不存在
> > > >
> > > > > 判断redis是否存在商品数据
> > > > >
> > > > > > redis命中，直接使用
> > > > >
> > > > > > redis未命中，从数据库中查找数据
> > > > > >
> > > > > > 并将数据放入redis一份
> >
> > 
> >
> > 当更新数据时，应该直接从数据库读取数据，为了防止数据错误
> >
> > > 生成更新锁（`"product_update_"+productId +".lock"`）
> > >
> > > > 系统检测到更新锁时，将不再允许从缓存中读取该数据
> > >
> > > 删除缓存
> > >
> > > 更新数据库
> > >
> > > 释放锁
> > >
> > > > `cluster.del(productUpdateLock);`





### 第十二天

> 购物车系统
>
> > 实现对购物车的增，删，查，改
>
> > 重难点在购物车的保存
> >
> > > 接收参数后需要判断当前购物车是新增还是更新
> > >
> > > > 1.根据userId productId 查询已存在的cart
> > > >
> > > > 2.判断已存在的cart是否为空
> > > >
> > > > > 2.1 为空，说明数据不存在
> > > > >
> > > > > > `insert`
> > > > >
> > > > > 2.2不为空，说明数据存在
> > > > >
> > > > > > `update` 将旧num与新num叠加
>
> 
>
> 订单功能
>
> > 查看，新增，删除订单
>
> > 重难点在于对数据的处理
> >
> > > 一个用户对应多个订单，需要关联两个表格
> >
> > > 使用 `resultMap` 对关联结果映射





### 第十三天

> mysql数据库高可用主(`master`)从(`slaver`)备份 + 数据库中间件（mycat）

> 数据库高可用主从备份
>
> 原理
>
> > `master`
> >
> > >开启一个二进制日志文件`log-bin`提供从节点监听同步
> > >
> > >`position`指针数据判断更新
> >
> > `slaver`
> >
> > > `I/O`:通过给定的主节点信息，登录到主节点，监听二进制文件
> > >
> > > 对比监听结果，获取`position`查看是否发生变动
> > >
> > > 中继日志
> > >
> > > > 存储更新的sql语句
> > >
> > > sql线程
> > >
> > > > 监听本地的中继日志判断更新，与主节点保持同步
>
> 
>
> 将云主机安装数据库软件（Percona）
>
> > 详见笔记
>
> 
> 
>
> 数据库中间件
>
> > 数据库集群常见概念
> >
> > > 故障转移
> > >
> > > > master宕机，自动将备份数据的slave顶替为新的master
> > >
> > > 读写分离
> > >
> > > > 在主节点中可以进行读和写
> > > >
> > > > 在从节点中只进行读的逻辑
> > >
> > > 备份机制
> > >
> > > > 单机备份
> > > >
> > > > > 单方向的主从复制,只能提供一次性的主从替换
> > > >
> > > > 双击热备
> > > >
> > > > > 双方向的主从复制，可以无限进行主从替换
>
> mycat 
>
> > 特点
> >
> > > Oracle,sqlServer,mysql
>
> 
>
> 数据库中间件的原理
>
> > 1.客户端将sql发送到mycat
> >
> > 2.mycat接收到sql
> >
> > 3.计算分片和读写分离的逻辑
> >
> > 4.从计算结果中，指定获取后端一个数据库连接
> >
> > 5.将计算结果过滤清洗，最终发送给后端数据库执行
>
> 
>
> 假死
>
> > 阻塞线程
> >
> > > 从线程接收到任务到任务执行结果中所有过程和进度中,线程都处在繁忙状态
> >
> > 非阻塞线程
> >
> > > 在线程处理任务时,任务不是时刻都繁忙的,所以线程可以利用这种空隙空闲出来处理其他问题--高并发中使用非阻塞的逻辑
> >
> > > 非阻塞引入,极大的提升mycat整体访问的并发效率
>
> 
>
> mycat安装测试案例
>
> > `server.xml`
> >
> > > 配置`mycat`的用户信息，数据源，账号，密码
> > >
> > > > `system`
> > > >
> > > > > 所有内容就是mycat软件的属性配置
> > > >
> > > > `user`
> > > >
> > > > > 定义了mycat的登录用户内容
> > > >
> > > > `qurantine`
> > > >
> > > > > 定义了mycat使用的防火墙逻辑
> > > >
> > > > > ip白名单
> > > > >
> > > > > sql黑名单
> > >
> > > > 详细配置
> > > >
> > > > > 略
> >
> > 
> >
> > `schema.xml`
> >
> > > 定义了当前mycat管理维护的逻辑库,逻辑表,数据分片,计算分片逻辑,后端数据库连接信息等
> > >
> > > > `schema`
> > > >
> > > > > 逻辑表名称，表示当前逻辑库的一张逻辑表
> > > >
> > > > `dataNode`
> > > >
> > > > > mycat中实现连接后端数据库，计算分片逻辑的中间标签
> > > >
> > > > `dataHost`
> > > >
> > > > > 一个dataHost管理一个数据库的集群(高可用的主从集群)
> > >
> > > > 配置详情
> > > >
> > > > > 略





### 第十四天

> mycat故障转移 + 读写分离 + 全局配置

> 故障转移
>
> > 原理
> >
> > > 客户端发送sql语句
> > >
> > > mycat获取兰姐sql，计算读写分离
> > >
> > > 获取后端连接对象发送
> > >
> > > 超时，调用心跳语句	`select user()`
> > >
> > > 多次尝试心跳，没有返回结果
> > >
> > > 根据`dataHost`配置的switchType的值，执行故障转移
> >
> > 配置文件的修改
> >
> > > `schema.xml`
> > >
> > > > `dataHost`中`switchType`：属性
> > > >
> > > > > `-1` ：不进行转移
> > > > >
> > > > > `1`：自动实现故障转移
>
> 
>
> 读写分离
>
> > 主从复制总结
> >
> > > 无论什么时候搭建主从，一定确定双方的历史数据一致
> >
> > 读的控制
> >
> > > dataHost标签中的 `balance`属性
> > >
> > > > `0`：不开启读写分离
> > > >
> > > > `1`：开启读写分离
> > > >
> > > > > 所有的读操作，都在除了第一个writeHost以外的所有Host标签中进行，当并发量极高时，第一个host也会参与一部分分担
> > > >
> > > > `2`：随机在所有writeHost和readHost读取
> > > >
> > > > `3`：在所有的readHost中读取数据
> > > >
> > > > > 如果没有`readHost`将会只从第一个``writeHost`中读取
> > > >
> > > > > 前提`writeHost`不能`=1`
> >
> > hash一致性
> >
> > > 使用datenode的名称做计算
> > >
> > > 使用每个计算方法指定的字段值
>
> 
>
> 全局表和ER分片表
>
> > 全局表
> >
> > > 一种是业务表格
> > >
> > > > 比如：`cart，product，user`
> > >
> > > 还有一种叫工具字典
> > >
> > > > 长期和业务表格做关联操作
> > >
> > > > 比如：`HTTP的状态码`
> >
> > 字典工具表的特点
> >
> > > 数据量不大
> > >
> > > 数据不发生巨大变化
>
> mycat不支持跨分片操作
>
> > 认为所有跨分片的操作会降低数据库中间键的计算效率
>
> 
>
> 使用全局配置
>
> > 为了解决工具字典作为分片表格 与 业务分片表格的底层不跨分片，可以使用全局表配置
> >
> > 多个分片中的真实库有对应的表格，并且在配置的逻辑表table中指定多个分片，但不需要指定分片计算规则（默认同步）
>
> #### ER分片表
>
> > mycat底层不支持夸分片操作,如果需求中有多个相关的分片表格(t_order,t_order_item)进行关联操作时,需要引入ER分片的配置逻辑--mycat首创的.mycat无法支持大量数据的多对多关系
>
> > 代码
> >
> > > 略







